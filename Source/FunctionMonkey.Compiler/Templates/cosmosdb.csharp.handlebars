using System;
using System.IO;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.Documents;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;

namespace {{Namespace}}
{
    public static class {{Name}}
    {
        [FunctionName("{{Name}}")]
        public static async Task Run(
            [CosmosDBTrigger(databaseName: "{{DatabaseName}}"
                             ,collectionName: "{{CollectionName}}"
                             ,ConnectionStringSetting = "{{ConnectionStringName}}"
                             ,LeaseCollectionName="{{LeaseCollectionName}}"
                             ,LeaseConnectionStringSetting="{{LeaseConnectionStringName}}"
                             {{#if LeaseCollectionPrefix}},LeaseCollectionPrefix="{{LeaseCollectionPrefix}}"{{/if}}
                             {{#if MaxItemsPerInvocation}},MaxItemsPerInvocation={{MaxItemsPerInvocation}}{{/if}}
                             {{#if FeedPollDelay}},FeedPollDelay={{FeedPollDelay}}{{/if}}
                             {{#if LeaseAcquireInterval}},LeaseAcquireInterval={{LeaseAcquireInterval}}{{/if}}
                             {{#if LeaseExpirationInterval}},LeaseExpirationInterval={{LeaseExpirationInterval}}{{/if}}
                             {{#if LeaseRenewInterval}},LeaseRenewInterval={{LeaseRenewInterval}}{{/if}}
                             {{#if CheckpointFrequency}},CheckpointFrequency={{CheckpointFrequency}}{{/if}}
                             {{#if LeasesCollectionThroughput}},LeasesCollectionThroughput={{LeasesCollectionThroughput}}{{/if}}
            )]
            IReadOnlyList<Document> input,
            ILogger log,
            ExecutionContext executionContext)
        {
            log.LogInformation("Cosmos change feed trigger function {{Name}} processed a request.");            
            
            {{#if IsDocumentBatchCommand}}
                {{CommandTypeName}} command = new {{CommandTypeName}}();
                command.Documents = input;
                var result = await FunctionMonkey.Runtime.CommandDispatcher.DispatchAsync(command);
                // The result will be useful when we want to include outputs too
            {{else}}
                foreach(Document document in input)
                {
                    {{CommandTypeName}} command = null;
                    {{#if IsDocumentCommand}}
                        command = new {{CommandTypeName}}();
                        command.Document = document;
                    {{else}}
                        {{#if ConvertToPascalCase}}
                            using (MemoryStream memoryStream = new MemoryStream())
                            {
                                document.SaveTo(memoryStream, SerializationFormattingPolicy.None, new JsonSerializerSettings
                                {
                                    ContractResolver = new CamelCasePropertyNamesContractResolver()
                                });
                                string json = Encoding.UTF8.GetString(memoryStream.ToArray());
                                command = JsonConvert.DeserializeObject<{{CommandTypeName}}>(json);
                            }    
                        {{else}}
                            command = new {{CommandTypeName}}();
                            {{#each CommandProperties}}
                                command.{{Name}} = document.GetPropertyValue<{{TypeName}}>("{{CosmosPropertyName}}");
                            {{/each}}
                        {{/if}}
                    {{/if}}

                    var result = await FunctionMonkey.Runtime.CommandDispatcher.DispatchAsync(command);
                    // The result will be useful when we want to include outputs too
                }
            {{/if}}
        }
    }
}
